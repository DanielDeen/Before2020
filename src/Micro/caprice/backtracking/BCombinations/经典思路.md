![img.png](img.png)

回溯法解决的问题都可以抽象成树形结构（N叉树），用树形结构来理解回溯就容易多了

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。

图中可以发现n相当于树的宽度，k相当于树的深度。

图中每次搜索到了叶子节点，我们就找到了一个结果。
相当于只需要把到叶子节点的结果收集起来，就可以求得n个数中k个数的组合集合。

组合问题是回溯法解决的经典问题，我们开始的时候列举一个很形象的例子，就是 n 为 100，k 为 50 的话，直接想法就是需要 50 层
for循环。

从而引出了回溯法就是解决这种 k 层 for 循环嵌套的问题。

然后进一步把回溯法的搜索过程抽象为树形结构，可以直观地看出搜索过程

接着用回溯法三部曲，初步分析了函数参数、终止条件和单层搜索。

### 性能分析

##### 子集问题分析
- 时间复杂度：O(2^n)，因为每个元素的状态无外呼取与不取
- 空间复杂度：O(n)，递归的深度为 n , 所以系统栈所用的空间为 O(n)，每一层递归所用的空间都是常数级别

##### 排列问题分析
- 时间复杂度：O(n!), 每一层节点为n , 第二层每一个分支都延伸了 n - 1 个分支，再往下就是 n - 2，所以 n * n-1 * n-2 ... 1 = n!
- 空间复杂度：O(n)，同子集

##### 组合问题分析
- 时间复杂度：O(2^n)，组合问题其实就是一种子集问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度
- 空间复杂度：O(n)

##### N皇后问题分析
- 时间复杂度: O(n!)，
- 空间复杂度：O(n)

##### 解数独问题分析
- 时间复杂度：O(9^m), m 是 '.' 的数目
- 空间复杂度： O(n^2)，递归的深度是 n^2